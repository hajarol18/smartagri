from odoo import models, fields, api
from odoo.exceptions import ValidationError

class Exploitation(models.Model):
    _name = 'exploitation.agri'
    _description = 'Exploitation Agricole'
    _rec_name = 'nom'

    nom = fields.Char(string="Nom de l'exploitation", required=True)
    proprietaire = fields.Char(string="Propriétaire")
    superficie_totale = fields.Float(string="Superficie totale (ha)", default=0.0)
    adresse = fields.Text(string="Adresse")
    ville = fields.Char(string="Ville")
    code_postal = fields.Char(string="Code postal")
    telephone = fields.Char(string="Téléphone")
    email = fields.Char(string="Email")
    
    # Données géographiques
    latitude = fields.Float(string="Latitude")
    longitude = fields.Float(string="Longitude")
    altitude = fields.Float(string="Altitude (m)")
    
    # Données climatiques
    zone_climatique = fields.Selection([
        ('mediterraneen', 'Méditerranéen'),
        ('oceanique', 'Océanique'),
        ('continental', 'Continental'),
        ('montagnard', 'Montagnard'),
    ], string="Zone climatique")
    
    # Données pédologiques
    type_sol = fields.Selection([
        ('argileux', 'Argileux'),
        ('limoneux', 'Limoneux'),
        ('sableux', 'Sableux'),
        ('calcaire', 'Calcaire'),
        ('humifere', 'Humifère'),
    ], string="Type de sol")
    
    # Données météorologiques
    derniere_import_meteo = fields.Datetime(string="Dernier import météo", readonly=True)
    prochaine_alerte_meteo = fields.Text(string="Prochaine alerte météo", readonly=True)
    
    # Relations (seront ajoutées plus tard)
    # parcelles_ids = fields.One2many('parcelle.agri', 'exploitation_id', string="Parcelles")
    # cultures_ids = fields.One2many('culture.agri', 'exploitation_id', string="Cultures")
    # interventions_ids = fields.One2many('intervention.agri', 'exploitation_id', string="Interventions")
    
    # Calculs automatiques (seront ajoutés plus tard)
    # nombre_parcelles = fields.Integer(string="Nombre de parcelles", compute='_compute_stats')
    # superficie_cultivee = fields.Float(string="Superficie cultivée (ha)", compute='_compute_stats')
    
    # @api.depends('parcelles_ids', 'cultures_ids')
    # def _compute_stats(self):
    #     for record in self:
    #         record.nombre_parcelles = len(record.parcelles_ids)
    #         record.superficie_cultivee = sum(record.parcelles_ids.mapped('superficie'))
    
    @api.constrains('superficie_totale')
    def _check_superficie(self):
        for record in self:
            if record.superficie_totale < 0:
                raise ValidationError("La superficie totale ne peut pas être négative.")
    
    def action_importer_meteo(self):
        """Importe automatiquement les données météo des 7 prochains jours"""
        for record in self:
            if not record.latitude or not record.longitude:
                raise ValidationError("Latitude et longitude sont requises pour importer la météo.")
            
            # Simuler l'import de données météo (remplacé plus tard par l'API Meteostat)
            from datetime import datetime, timedelta
            import random
            
            # Créer 7 jours de données météo simulées
            for i in range(7):
                date_meteo = datetime.now() + timedelta(days=i)
                
                # Données simulées (remplacées par l'API réelle)
                temperature = random.uniform(15, 30)
                precipitations = random.uniform(0, 20)
                humidite = random.uniform(40, 80)
                vent_vitesse = random.uniform(0, 15)
                
                # Créer l'enregistrement météo
                meteo_data = self.env['meteo.data'].create({
                    'date': date_meteo,
                    'exploitation_id': record.id,
                    'latitude': record.latitude,
                    'longitude': record.longitude,
                    'temperature': temperature,
                    'precipitation': precipitations,
                    'humidite': humidite,
                    'vent_vitesse': vent_vitesse,
                    'pression': 1013.25,
                    'rayonnement_solaire': random.uniform(0, 1000),
                })
                
                # Vérifier les alertes automatiquement
                meteo_data.action_verifier_alertes()
            
            # Mettre à jour les champs de l'exploitation
            record.derniere_import_meteo = datetime.now()
            
            # Vérifier s'il y a des alertes actives
            alertes_actives = self.env['meteo.data'].search([
                ('exploitation_id', '=', record.id),
                '|',
                ('alerte_gel', '=', True),
                '|',
                ('alerte_canicule', '=', True),
                '|',
                ('alerte_secheresse', '=', True),
                '|',
                ('alerte_inondation', '=', True),
                ('alerte_vent', '=', True)
            ], limit=1)
            
            if alertes_actives:
                record.prochaine_alerte_meteo = f"⚠️ Alerte détectée : {alertes_actives[0].name}"
            else:
                record.prochaine_alerte_meteo = "✅ Aucune alerte météo active"
            
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': 'Import Météo Réussi',
                    'message': f'7 jours de données météo importés pour {record.nom}. {len(alertes_actives)} alerte(s) détectée(s).',
                    'type': 'success',
                }
            }
